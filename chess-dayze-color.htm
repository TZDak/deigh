<html><head><base href><title>chess.dayze - Chess with Deigh Support</title>
<style>
:root {
  --scale-factor: 0.8;
  --base-square-size: 60px;
  --square-size: min(calc(10vw * var(--scale-factor)), calc(var(--base-square-size) * var(--scale-factor)));
  --board-color-light: #f0d9b5;
  --board-color-dark: #b58863;
  --piece-color-white: #e8e8ff;
  --piece-color-black: #480828;
  --bottom-color: var(--piece-color-white);
  --top-color: var(--piece-color-black);
  --opponent-color: #888;
}

.square.light {
  background-color: var(--board-color-light);
}

.square.dark {
  background-color: var(--board-color-dark);
}

body {
  margin: 0;
  padding: 20px;
  font-family: 'Inter', system-ui, sans-serif;
  background: #1a1a1a;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
}

.header {
  margin: 20px 0;
  text-align: center; 
}

.logo {
  font-size: calc(2.5rem * var(--scale-factor));
  font-weight: 800;
  color: #fff;
  letter-spacing: -0.05em;
}

.board {
  display: grid;
  grid-template-columns: repeat(8, var(--square-size));
  grid-template-rows: repeat(8, var(--square-size));
  border: 2px solid #333;
  box-shadow: 0 0 30px rgba(0,0,0,0.3);
}

.square {
  width: var(--square-size);
  height: var(--square-size);
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: calc(var(--square-size) * 0.7);
  cursor: pointer;
  transition: background-color 0.2s;
}

.square.light {
  background-color: var(--board-color-light);
}

.square.dark {
  background-color: var(--board-color-dark);
}

.square:hover {
  filter: brightness(1.1);
}

.piece {
  user-select: none;
  transition: color 0.5s;
}

.piece.bottom {
  color: var(--bottom-color, var(--piece-color-white));
}

.piece.top {
  color: var(--top-color, var(--piece-color-black));
}

@keyframes checkBlink {
  0%, 100% { opacity: 0; }
  50% { opacity: 1; }
}

.piece.in-check::before {
  content: attr(data-piece);
  position: absolute; 
  transform: scale(1.15);
  z-index: -1;
  color: var(--opponent-color);
  animation: checkBlink 1s infinite;
}

.piece.in-check:hover::before {
  animation: none;
  opacity: 1;
}

.controls {
  margin-top: 20px;
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
}

button {
  background: #333;
  color: #fff;
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.2s;
}

button:hover {
  background: #444;
}

.status {
  margin-top: 20px;
  font-size: calc(1.2rem * var(--scale-factor));
}

.square.selected {
  background-color: #6b8f3d !important;
}

.square.valid-move {
  background-color: #81c784 !important;
}

.square.valid-capture {
  background-color: #ef5350 !important;
}

.square.valid-enpassant {
  background-color: #c781c4 !important;
}

.square.valid-castle {
  background-color: #54b4f7 !important;
}

.square.valid-castle {
  background-color: #54b4f7 !important;
}

.message-box {
  margin: 20px;
  padding: 20px;
  background: #333;
  border-radius: 5px;
  max-width: calc(600px * var(--scale-factor));
  line-height: 1.5;
}

</style>
</head>
<body>

<div class="board cycling" id="board"></div>

<div class="controls">
  <button id="newGame">New Game</button>
  <button id="undoMove">Undo Move</button>  
  <button id="copyBoard">Copy Board to Clipboard</button>
</div>

<div class="status" id="status">Either side to move</div>

<div class="message-box" id="debug">System and debug messages show up here.</div>

<script>const CAPTURE_LOOKUP = new Uint8Array(4096);

function initializeMoveTables() {
  TOP_MOVES.fill(0);
  BOTTOM_MOVES.fill(0);
  
  const setMove = (fromRow, fromCol, toRow, toCol, moveFlags, forTop) => {
    const index = (fromRow * 8 + fromCol) * 64 + (toRow * 8 + toCol);
    if (forTop) {
      TOP_MOVES[index] |= moveFlags;
    } else {
      BOTTOM_MOVES[index] |= moveFlags;
    }
  };

  for (let fromRow = 0; fromRow < 8; fromRow++) {
    for (let fromCol = 0; fromCol < 8; fromCol++) {
      // Rook & Queen moves/captures (orthogonal)
      for (let toRow = 0; toRow < 8; toRow++) {
        if (toRow !== fromRow) {
          setMove(fromRow, fromCol, toRow, fromCol, MOVES.ROOK_MOVE | MOVES.QUEEN_MOVE, true);
          setMove(fromRow, fromCol, toRow, fromCol, MOVES.ROOK_CAPTURE | MOVES.QUEEN_CAPTURE, true);
          setMove(fromRow, fromCol, toRow, fromCol, MOVES.ROOK_MOVE | MOVES.QUEEN_MOVE, false);
          setMove(fromRow, fromCol, toRow, fromCol, MOVES.ROOK_CAPTURE | MOVES.QUEEN_CAPTURE, false);
        }
      }
      for (let toCol = 0; toCol < 8; toCol++) {
        if (toCol !== fromCol) {
          setMove(fromRow, fromCol, fromRow, toCol, MOVES.ROOK_MOVE | MOVES.QUEEN_MOVE, true);
          setMove(fromRow, fromCol, fromRow, toCol, MOVES.ROOK_CAPTURE | MOVES.QUEEN_CAPTURE, true);
          setMove(fromRow, fromCol, fromRow, toCol, MOVES.ROOK_MOVE | MOVES.QUEEN_MOVE, false);
          setMove(fromRow, fromCol, fromRow, toCol, MOVES.ROOK_CAPTURE | MOVES.QUEEN_CAPTURE, false);
        }
      }

      // Bishop & Queen moves/captures (diagonal)

      // Bishop & Queen moves/captures (diagonal)
      for (let i = 1; i < 8; i++) {
        [[-i, -i], [-i, i], [i, -i], [i, i]].forEach(([rowDiff, colDiff]) => {
          const toRow = fromRow + rowDiff;
          const toCol = fromCol + colDiff;
          if (toRow >= 0 && toRow < 8 && toCol >= 0 && toCol < 8) {
            setMove(fromRow, fromCol, toRow, toCol, MOVES.BISHOP_MOVE | MOVES.QUEEN_MOVE, true);
            setMove(fromRow, fromCol, toRow, toCol, MOVES.BISHOP_CAPTURE | MOVES.QUEEN_CAPTURE, true);
            setMove(fromRow, fromCol, toRow, toCol, MOVES.BISHOP_MOVE | MOVES.QUEEN_MOVE, false);
            setMove(fromRow, fromCol, toRow, toCol, MOVES.BISHOP_CAPTURE | MOVES.QUEEN_CAPTURE, false);
          }
        });
      }

      // Knight moves/captures
      [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]].forEach(([rowDiff, colDiff]) => {
        const toRow = fromRow + rowDiff;
        const toCol = fromCol + colDiff;
        if (toRow >= 0 && toRow < 8 && toCol >= 0 && toCol < 8) {
          setMove(fromRow, fromCol, toRow, toCol, MOVES.KNIGHT_MOVE | MOVES.KNIGHT_CAPTURE, true);
          setMove(fromRow, fromCol, toRow, toCol, MOVES.KNIGHT_MOVE | MOVES.KNIGHT_CAPTURE, false);
        }
      });

      // King moves/captures
      for (let rowDiff = -1; rowDiff <= 1; rowDiff++) {
        for (let colDiff = -1; colDiff <= 1; colDiff++) {
          if (rowDiff === 0 && colDiff === 0) continue;
          const toRow = fromRow + rowDiff;
          const toCol = fromCol + colDiff;
          if (toRow >= 0 && toRow < 8 && toCol >= 0 && toCol < 8) {
            setMove(fromRow, fromCol, toRow, toCol, MOVES.KING_MOVE | MOVES.KING_CAPTURE, true);
            setMove(fromRow, fromCol, toRow, toCol, MOVES.KING_MOVE | MOVES.KING_CAPTURE, false);
          }
        }
      }

      // Pawn moves/captures (different for top/bottom)
      // Bottom pawns move up (negative row)
      if (fromRow > 0) {
        setMove(fromRow, fromCol, fromRow - 1, fromCol, MOVES.PAWN_MOVE, false);
        if (fromRow === 6) {
          setMove(fromRow, fromCol, fromRow - 2, fromCol, MOVES.PAWN_MOVE, false);
        }
        if (fromCol > 0) {
          setMove(fromRow, fromCol, fromRow - 1, fromCol - 1, MOVES.PAWN_CAPTURE, false);
        }
        if (fromCol < 7) {
          setMove(fromRow, fromCol, fromRow - 1, fromCol + 1, MOVES.PAWN_CAPTURE, false);
        }
      }

      // Top pawns move down (positive row)
      if (fromRow < 7) {
        setMove(fromRow, fromCol, fromRow + 1, fromCol, MOVES.PAWN_MOVE, true);
        if (fromRow === 1) {
          setMove(fromRow, fromCol, fromRow + 2, fromCol, MOVES.PAWN_MOVE, true);
        }
        if (fromCol > 0) {
          setMove(fromRow, fromCol, fromRow + 1, fromCol - 1, MOVES.PAWN_CAPTURE, true);
        }
        if (fromCol < 7) {
          setMove(fromRow, fromCol, fromRow + 1, fromCol + 1, MOVES.PAWN_CAPTURE, true);
        }
      }

      // En passant squares
      if (fromRow === 3) {
        if (fromCol > 0) setMove(fromRow, fromCol, fromRow, fromCol - 1, MOVES.EN_PASSANT, false);
        if (fromCol < 7) setMove(fromRow, fromCol, fromRow, fromCol + 1, MOVES.EN_PASSANT, false);
      }
      if (fromRow === 4) {
        if (fromCol > 0) setMove(fromRow, fromCol, fromRow, fromCol - 1, MOVES.EN_PASSANT, true);
        if (fromCol < 7) setMove(fromRow, fromCol, fromRow, fromCol + 1, MOVES.EN_PASSANT, true);
      }

      // Deigh moves
      for (const path of deighPaths) {
        const endMove = path[path.length - 1];
        const toRow = fromRow + endMove[0];
        const toCol = fromCol + endMove[1];
        if (toRow >= 0 && toRow < 8 && toCol >= 0 && toCol < 8) {
          setMove(fromRow, fromCol, toRow, toCol, MOVES.DEIGH_MOVE | MOVES.DEIGH_CAPTURE, true);
          setMove(fromRow, fromCol, toRow, toCol, MOVES.DEIGH_MOVE | MOVES.DEIGH_CAPTURE, false);
        }
      }
    }
  }
}

const board = document.getElementById('board');
const status = document.getElementById('status');
const debug = document.getElementById('debug');
debug.textContent = "Chess with deigh support";
let selectedSquare = null;
let sideChosen = false;
let topTeamMovedFirst = null;
let bottomTeamMovedFirst = null;
let animationFrame = 0;
let colorIndex = 0;
let chosenColorIndex = null;
let chosenBottomColor = null;
let chosenTopColor = null;
let chosenColor = null;
const lightSquareColors = [
  '#b7c9d8', '#c5cdcf', '#d3d1c6', '#e1d5bd', '#f0d9b5', 
  '#edd2a7', '#f0d9b5', '#ecddc6', '#e8e2d7', '#e4e6e8', '#e1ebf9'
];

const darkSquareColors = [
  '#06101e', '#312e2f', '#5d4c40', '#896a51', '#b58863',
  '#daa477', '#b58863', '#91745c', '#6e6055', '#4a4c4e', '#273948'
];
const bottomPlayerColors = {
  0: '#ff3700',
  1: '#ffa500',
  2: '#eeff00',
  3: '#7fff00',
  4: '#10ff00',
  5: '#00ff5d',
  6: '#00ffc7',
  7: '#00c7ff',
  8: '#0059ff',
  9: '#1000ff',
  10: '#7f00ff',
  11: '#ee00ff',
  12: '#ff00a1',
  13: '#ff0037'
};
const topPlayerColors = {
  0: '#00c7ff',
  1: '#0059ff',
  2: '#1000ff',
  3: '#7f00ff',
  4: '#ee00ff',
  5: '#ff00a1',
  6: '#ff0037',
  7: '#ff3700',
  8: '#ffa500',
  9: '#eeff00',
  10: '#7fff00',
  11: '#10ff00',
  12: '#00ff5d',
  13: '#00ffc7'
};
const deighPaths = [[[0, -1], [0, -2], [1, -2]], [[0, -1], [0, -2], [-1, -2]], [[0, -1], [-1, -1], [-2, -1]], [[0, -1], [1, -1], [2, -1]], [[1, 0], [2, 0], [2, 1]], [[1, 0], [2, 0], [2, -1]], [[1, 0], [1, 1], [1, 2]], [[1, 0], [1, -1], [1, -2]], [[0, 1], [0, 2], [1, 2]], [[0, 1], [0, 2], [-1, 2]], [[0, 1], [-1, 1], [-2, 1]], [[0, 1], [1, 1], [2, 1]], [[-1, 0], [-2, 0], [-2, 1]], [[-1, 0], [-2, 0], [-2, -1]], [[-1, 0], [-1, 1], [-1, 2]], [[-1, 0], [-1, -1], [-1, -2]]];
const MOVES = {
  PAWN_MOVE: 0x0001,
  PAWN_CAPTURE: 0x0002,
  EN_PASSANT: 0x0004,
  BISHOP_MOVE: 0x0008,
  BISHOP_CAPTURE: 0x0010,
  KNIGHT_MOVE: 0x0020,
  KNIGHT_CAPTURE: 0x0080,
  DEIGH_MOVE: 0x0100,
  DEIGH_CAPTURE: 0x0200,
  ROOK_MOVE: 0x0400,
  ROOK_CAPTURE: 0x0800,
  QUEEN_MOVE: 0x1000,
  QUEEN_CAPTURE: 0x2000,
  KING_MOVE: 0x4000,
  KING_CAPTURE: 0x8000
};

// Create two 64x64 tables for moves (one for each player)
const TOP_MOVES = new Uint16Array(4096);
const BOTTOM_MOVES = new Uint16Array(4096);
const initialBoard = [
  ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
  ['♟', '♠', '♟', '♟', '♟', '♟', '♠', '♟'],
  ['', '', '', '', '', '', '', ''],
  ['', '', '', '', '', '', '', ''],
  ['', '', '', '', '', '', '', ''],
  ['', '', '', '', '', '', '', ''],
  ['♙', '♤', '♙', '♙', '♙', '♙', '♤', '♙'],
  ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
];
let currentBoard = JSON.parse(JSON.stringify(initialBoard));
let isTopTeamsTurn = null;
let moveHistory = [];
let clickedPieceColor = null;
let currentBoardCopy = JSON.parse(JSON.stringify(initialBoard));
const numLightSquareColors = Object.keys(lightSquareColors).length;
const numDarkSquareColors = Object.keys(darkSquareColors).length;
const numColors = Object.keys(bottomPlayerColors).length;
let lastMove = null;
let kingMoved = {
  white: false,
  black: false
};
let rookMoved = {
  whiteKing: false,
  whiteQueen: false,
  blackKing: false,
  blackQueen: false
};
const PIECE_BITS = {
  PAWN: 1 << 0,
  BISHOP: 1 << 1,
  KNIGHT: 1 << 2,
  DEIGH: 1 << 3,
  ROOK: 1 << 4,
  QUEEN: 1 << 5,
  KING: 1 << 6
};
function getPieceBits(piece) {
  switch (piece) {
    case '♟':
    case '♙':
      return PIECE_BITS.PAWN;
    case '♝':
    case '♗':
      return PIECE_BITS.BISHOP;
    case '♞':
    case '♘':
      return PIECE_BITS.KNIGHT;
    case '♠':
    case '♤':
      return PIECE_BITS.DEIGH;
    case '♜':
    case '♖':
      return PIECE_BITS.ROOK;
    case '♛':
    case '♕':
      return PIECE_BITS.QUEEN;
    case '♚':
    case '♔':
      return PIECE_BITS.KING;
    default:
      return 0;
  }
}

function isTopTeamPiece(piece) {
  return ['♜', '♞', '♝', '♛', '♚', '♟', '♠'].includes(piece);
}

function isBottomTeamPiece(piece) {
  return ['♖', '♘', '♗', '♕', '♔', '♙', '♤'].includes(piece);
}

function isCurrentTeamPiece(piece) {
    const isTopTurn = moveHistory.length % 2 === 0 === topTeamMovedFirst;
    return isTopTurn ? isTopTeamPiece(piece) : isBottomTeamPiece(piece);
}

function isOpposingTeamPiece(piece) {
   const isTopTurn = moveHistory.length % 2 === 0 === topTeamMovedFirst;
   return isTopTurn ? isBottomTeamPiece(piece) : isTopTeamPiece(piece);
}

function findPlayerPieces(board, isTopPlayer) {
    const pieces = [];
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = board[row][col];
            if (piece && isTopTeamPiece(piece) === isTopPlayer) {
                pieces.push([row, col]);
            }
        }
    }
    return pieces;
}

function getValidMoves(isTopPlayer) {
    const validMoves = [];
    const pieces = findPlayerPieces(currentBoard, isTopPlayer);
    
    // For each piece the player has
    for (const [fromRow, fromCol] of pieces) {
        const piece = currentBoard[fromRow][fromCol];
        
        // For each potential destination square
        for (let toRow = 0; toRow < 8; toRow++) {
            for (let toCol = 0; toCol < 8; toCol++) {
                // Use existing isValidMove function and check validation
                if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                    if (!wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece)) {
                        validMoves.push({
                            piece,
                            from: [fromRow, fromCol],
                            to: [toRow, toCol]
                        });
                    }
                }
            }
        }
    }
    
    return validMoves;
}
function isGameOver() {
    // Check whose turn it is
    const isTopTurn = moveHistory.length % 2 === 0 === topTeamMovedFirst;
    
    // Get all valid moves for current player
    const validMoves = getValidMoves(isTopTurn);
    
    if (validMoves.length === 0) {
        // No valid moves - either checkmate or stalemate
        const inCheck = isKingInCheck(isTopTurn);
        return {
            isOver: true,
            type: inCheck ? 'checkmate' : 'stalemate',
            winner: inCheck ? (isTopTurn ? 'bottom' : 'top') : null
        };
    }
    
    return {
        isOver: false,
        type: null,
        winner: null
    };
}

// RETAINED EMERGENT FEATURE:
// The deigh piece can capture members of its own team. This evolved as an 
// emergent property and intentionally kept, allowing a player's deigh to 
// remove their own pieces that might be inadvertently protecting the from attack. 
// This adds a tactical element where a piece that's blocking an attack line might 
// be removed to allow a sneak attack, ironically by the light of deigh.
function isValidDeighMove(fromRow, fromCol, toRow, toCol) {
  const deighPaths = [[[0, -1], [0, -2], [1, -2]], [[0, -1], [0, -2], [-1, -2]], [[0, -1], [-1, -1], [-2, -1]], [[0, -1], [1, -1], [2, -1]], [[1, 0], [2, 0], [2, 1]], [[1, 0], [2, 0], [2, -1]], [[1, 0], [1, 1], [1, 2]], [[1, 0], [1, -1], [1, -2]], [[0, 1], [0, 2], [1, 2]], [[0, 1], [0, 2], [-1, 2]], [[0, 1], [-1, 1], [-2, 1]], [[0, 1], [1, 1], [2, 1]], [[-1, 0], [-2, 0], [-2, 1]], [[-1, 0], [-2, 0], [-2, -1]], [[-1, 0], [-1, 1], [-1, 2]], [[-1, 0], [-1, -1], [-1, -2]]];
  return deighPaths.some(path => {
    let currentRow = fromRow;
    let currentCol = fromCol;
    for (let i = 0; i < path.length; i++) {
      const nextRow = fromRow + path[i][0];
      const nextCol = fromCol + path[i][1];
      if (nextRow === toRow && nextCol === toCol) {
        for (let j = 0; j < i; j++) {
          const checkRow = fromRow + path[j][0];
          const checkCol = fromCol + path[j][1];
          if (checkRow < 0 || checkRow >= 8 || checkCol < 0 || checkCol >= 8 || currentBoard[checkRow][checkCol] !== '') {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  });
}
function initializeBoard() {
  kingMoved = {
    white: false,
    black: false
  };
  rookMoved = {
    whiteKing: false,
    whiteQueen: false,
    blackKing: false,
    blackQueen: false
  };
  board.innerHTML = '';
  currentBoard = JSON.parse(JSON.stringify(initialBoard));
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const square = document.createElement('div');
      square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
      const piece = currentBoard[row][col];
      if (piece) {
        const span = document.createElement('span');
        span.className = `piece ${isTopTeamPiece(piece) ? 'top' : 'bottom'}`;
        span.textContent = piece;
        square.appendChild(span);
      }
      square.addEventListener('click', () => handleSquareClick(row, col));
      board.appendChild(square);
    }
  }
  updateBoard(true);
  updateMoveStatus();
}

// Core function that does the actual check detection
function checkKingInDanger(isTopTeamKing, board) {
  let kingRow = -1;
  let kingCol = -1;
  const kingPiece = isTopTeamKing ? '♚' : '♔';
  
  // Find king
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      if (board[row][col] === kingPiece) {
        kingRow = row;
        kingCol = col;
        break;
      }
    }
    if (kingRow !== -1) break;
  }

  // If king is missing, that's a special case
  if (kingRow === -1) {
    return 'missing';
  }
  
  console.log('Checking danger for', isTopTeamKing ? 'top' : 'bottom', 'king at', kingRow, kingCol);

  // Check each square for potential threats
  for (let fromRow = 0; fromRow < 8; fromRow++) {
    for (let fromCol = 0; fromCol < 8; fromCol++) {
      const piece = board[fromRow][fromCol];
      if (!piece || isTopTeamPiece(piece) === isTopTeamKing) continue;
      
      // Check if this piece could capture the king
      if ((piece === '♙' || piece === '♟') && 
          Math.abs(fromCol - kingCol) === 1 && 
          (isTopTeamKing ? kingRow === fromRow + 1 : kingRow === fromRow - 1)) {
        console.log('Pawn at', fromRow, fromCol, 'threatens king');
        return true;
      }
      
      if ((piece === '♘' || piece === '♞') && 
          ((Math.abs(fromRow - kingRow) === 2 && Math.abs(fromCol - kingCol) === 1) ||
           (Math.abs(fromRow - kingRow) === 1 && Math.abs(fromCol - kingCol) === 2))) {
        console.log('Knight at', fromRow, fromCol, 'threatens king');
        return true;
      }
      
      if ((piece === '♗' || piece === '♝') && 
          Math.abs(fromRow - kingRow) === Math.abs(fromCol - kingCol)) {
        // Check if path is clear
        const rowStep = Math.sign(kingRow - fromRow);
        const colStep = Math.sign(kingCol - fromCol);
        let blocked = false;
        let testRow = fromRow + rowStep;
        let testCol = fromCol + colStep;
        while (testRow !== kingRow || testCol !== kingCol) {
          if (board[testRow][testCol] !== '') {
            blocked = true;
            break;
          }
          testRow += rowStep;
          testCol += colStep;
        }
        if (!blocked) {
          console.log('Bishop at', fromRow, fromCol, 'threatens king');
          return true;
        }
      }
      
      if ((piece === '♖' || piece === '♜') && 
          (fromRow === kingRow || fromCol === kingCol)) {
        // Check if path is clear
        const rowStep = Math.sign(kingRow - fromRow);
        const colStep = Math.sign(kingCol - fromCol);
        let blocked = false;
        let testRow = fromRow + rowStep;
        let testCol = fromCol + colStep;
        while (testRow !== kingRow || testCol !== kingCol) {
          if (board[testRow][testCol] !== '') {
            blocked = true;
            break;
          }
          testRow += rowStep;
          testCol += colStep;
        }
        if (!blocked) {
          console.log('Rook at', fromRow, fromCol, 'threatens king');
          return true;
        }
      }
      
      if ((piece === '♕' || piece === '♛') && 
          (fromRow === kingRow || fromCol === kingCol || 
           Math.abs(fromRow - kingRow) === Math.abs(fromCol - kingCol))) {
        // Check if path is clear
        const rowStep = Math.sign(kingRow - fromRow);
        const colStep = Math.sign(kingCol - fromCol);
        let blocked = false;
        let testRow = fromRow + rowStep;
        let testCol = fromCol + colStep;
        while (testRow !== kingRow || testCol !== kingCol) {
          if (board[testRow][testCol] !== '') {
            blocked = true;
            break;
          }
          testRow += rowStep;
          testCol += colStep;
        }
        if (!blocked) {
          console.log('Queen at', fromRow, fromCol, 'threatens king');
          return true;
        }
      }
      
      if ((piece === '♠' || piece === '♤')) {
        // Check each possible deigh path
        for (const path of deighPaths) {
          // Check each position along the path
          for (let step = 0; step < path.length; step++) {
            const targetRow = fromRow + path[step][0];
            const targetCol = fromCol + path[step][1];
            
            // If this position is where the king is
            if (targetRow === kingRow && targetCol === kingCol) {
              // Check if path to here is clear
              let pathClear = true;
              for (let i = 0; i < step; i++) {
                const checkRow = fromRow + path[i][0];
                const checkCol = fromCol + path[i][1];
                if (checkRow < 0 || checkRow >= 8 || checkCol < 0 || checkCol >= 8 || 
                  board[checkRow][checkCol] !== '') {
                  pathClear = false;
                  break;
                }
              }
              if (pathClear) {
                console.log('Deigh at', fromRow, fromCol, 'threatens king');
                return true;
              }
            }
          }
        }
      }
    }
  }
  return false;
}

// Function to check if current player's king is in check
function isCurrentKingInCheck() {
  const isTopTurn = moveHistory.length % 2 === 0 === topTeamMovedFirst;
  return checkKingInDanger(isTopTurn, currentBoard);
}

// Function to check if a king would be in check in a hypothetical position
function wouldKingBeInCheck(isCheckingCurrentTeam, hypotheticalBoard) {
  const isTopTeam = isCheckingCurrentTeam ? 
    (moveHistory.length % 2 === 0 === topTeamMovedFirst) : 
    (moveHistory.length % 2 !== 0 === topTeamMovedFirst);
  console.log('isCheckingCurrentTeam:', isCheckingCurrentTeam);
  console.log('moveHistory.length:', moveHistory.length);
  console.log('topTeamFirst:', topTeamMovedFirst);
  console.log('isTopTeam:', isTopTeam);
  return checkKingInDanger(isTopTeam, hypotheticalBoard || currentBoard);
}

function handleSquareClick(row, col) {
  // First click - choosing a side
  if (!sideChosen) {
    const piece = currentBoard[row][col];
    if (piece) {
      sideChosen = true;
      topTeamMovedFirst = isTopTeamPiece(piece);
      bottomTeamMovedFirst = !topTeamMovedFirst;
      isTopTeamsTurn = topTeamMovedFirst;  // first player to move
      board.classList.remove('cycling');

      selectedSquare = [row, col];
      document.querySelectorAll('.square')[row * 8 + col].classList.add('selected');
      showValidMoves(row, col);
      updateMoveStatus();
      return;
    }
    return;
  }

  // Handling piece selection and movement
  const piece = currentBoard[row][col];
  
  // If no piece is selected
  if (selectedSquare === null) {
    // Ignore clicks on empty squares or opponent's pieces
    if (!piece || !isCurrentTeamPiece(piece)) {
      return;
    }
    
    // Select the piece
    selectedSquare = [row, col];
    document.querySelectorAll('.square')[row * 8 + col].classList.add('selected');
    showValidMoves(row, col);
    updateMoveStatus();  // Add this to show which piece is selected
    return;
  }

  // A piece is already selected
  const [selectedRow, selectedCol] = selectedSquare;
  
  // Clicking the same square - deselect
  if (row === selectedRow && col === selectedCol) {
      clearHighlights();
      selectedSquare = null;
      updateMoveStatus();
      return;
  }

  // Attempt to make a move
  const selectedPiece = currentBoard[selectedRow][selectedCol];
  if (!isValidMove(selectedRow, selectedCol, row, col)) return;
  if (wouldLeaveKingInCheck(selectedRow, selectedCol, row, col, selectedPiece)) return;

  // Store old state for undo
  const oldKingMoved = { ...kingMoved };
  const oldRookMoved = { ...rookMoved };

  // Handle castling moves
  if (selectedPiece === '♔') {
    kingMoved.white = true;
    if (Math.abs(col - selectedCol) === 2) {
      if (col > selectedCol) {
        currentBoard[row][col - 1] = currentBoard[row][7];
        currentBoard[row][7] = '';
        rookMoved.whiteKing = true;
      } else {
        currentBoard[row][col + 1] = currentBoard[row][0];
        currentBoard[row][0] = '';
        rookMoved.whiteQueen = true;
      }
    }
  } else if (selectedPiece === '♚') {
    kingMoved.black = true;
    if (Math.abs(col - selectedCol) === 2) {
      if (col > selectedCol) {
        currentBoard[row][col - 1] = currentBoard[row][7];
        currentBoard[row][7] = '';
        rookMoved.blackKing = true;
      } else {
        currentBoard[row][col + 1] = currentBoard[row][0];
        currentBoard[row][0] = '';
        rookMoved.blackQueen = true;
      }
    }
  } else if (selectedPiece === '♖') {
    if (selectedCol === 0) rookMoved.whiteQueen = true;
    if (selectedCol === 7) rookMoved.whiteKing = true;
  } else if (selectedPiece === '♜') {
    if (selectedCol === 0) rookMoved.blackQueen = true;
    if (selectedCol === 7) rookMoved.blackKing = true;
  }

  // Handle en passant captures
  if ((selectedPiece === '♙' || selectedPiece === '♟') && 
      Math.abs(col - selectedCol) === 1 && 
      !currentBoard[row][col]) {
    currentBoard[selectedRow][col] = '';
  }

  // Record the move
  moveHistory.push({
    from: [selectedRow, selectedCol],
    to: [row, col],
    piece: selectedPiece,
    kingMoved: oldKingMoved,
    rookMoved: oldRookMoved,
    capturedPiece: currentBoard[row][col],
    enPassantCapturedPiece: ((selectedPiece === '♙' || selectedPiece === '♟') && 
                            Math.abs(col - selectedCol) === 1 && 
                            !currentBoard[row][col]) ? currentBoard[selectedRow][col] : null
});
  
  lastMove = moveHistory[moveHistory.length - 1];

  // Get the piece before moving it
  const movingPiece = currentBoard[selectedRow][selectedCol];
  const pieceName = movingPiece === '♙' || movingPiece === '♟' ? 'pawn' :
                  movingPiece === '♖' || movingPiece === '♜' ? 'rook' :
                  movingPiece === '♘' || movingPiece === '♞' ? 'knight' :
                  movingPiece === '♗' || movingPiece === '♝' ? 'bishop' :
                  movingPiece === '♕' || movingPiece === '♛' ? 'queen' :
                  movingPiece === '♔' || movingPiece === '♚' ? 'king' :
                  movingPiece === '♤' || movingPiece === '♠' ? 'deigh' : '';

  // Determine move type
  let moveType = '';
  const isCapture = currentBoard[row][col] !== ''; // Regular capture
  const isEnPassant = (movingPiece === '♙' || movingPiece === '♟') && 
                     Math.abs(col - selectedCol) === 1 && 
                     !currentBoard[row][col]; // En passant capture
  const isCastling = (movingPiece === '♔' || movingPiece === '♚') && 
                    Math.abs(col - selectedCol) === 2; // Castling move

  if (isCastling) {
    moveType = col > selectedCol ? ' (kingside castle)' : ' (queenside castle)';
  } else if (isCapture || isEnPassant) {
    const capturedPiece = isEnPassant ? currentBoard[selectedRow][col] : currentBoard[row][col];
    moveType = ` capturing ${capturedPiece}`;
    if (isEnPassant) moveType += ' en passant';
  }

  // Make the move
  currentBoard[row][col] = movingPiece;
  currentBoard[selectedRow][selectedCol] = '';

  // Show the move in debug
  debug.textContent = `${pieceName} (${movingPiece}) moved from ${String.fromCharCode(97 + selectedCol)}${8 - selectedRow} to ${String.fromCharCode(97 + col)}${8 - row}${moveType}`;

  // Clear selection BEFORE updating status
  selectedSquare = null;

  // Switch current player
  isTopTeamsTurn = !isTopTeamsTurn;
  
  // Check for game over
  const gameState = isGameOver();
  if (gameState.isOver) {
    const message = gameState.type === 'checkmate' 
      ? `Game Over - ${gameState.winner} player wins by checkmate!`
      : 'Game Over - Stalemate!';
    debug.textContent = message;
  }

  // Update display
  updateBoard();
  clearHighlights();
  selectedSquare = null;
}

function isValidMove(fromRow, fromCol, toRow, toCol) {
  const piece = currentBoard[fromRow][fromCol];
  if (moveHistory.length === 0 && !sideChosen || !isCurrentTeamPiece(piece)) {
    return false;
  }

  const targetPiece = currentBoard[toRow][toCol];
  
  if (piece === '♠' || piece === '♤') {
    return isValidDeighMove(fromRow, fromCol, toRow, toCol) && !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
  }

  if (piece === '♙') {
    if (fromRow === 6) {
      if (toCol === fromCol && toRow === fromRow - 1 && !targetPiece || 
          toCol === fromCol && toRow === fromRow - 2 && !targetPiece && !currentBoard[fromRow - 1][fromCol]) {
        return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
      }
    }
    if (toCol === fromCol && toRow === fromRow - 1 && !targetPiece) {
      return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
    }
    if (Math.abs(toCol - fromCol) === 1 && toRow === fromRow - 1) {
      if (targetPiece && isOpposingTeamPiece(targetPiece)) {
        return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
      }
      if (!targetPiece && lastMove && lastMove.piece === '♟' && 
          lastMove.from[0] === 1 && lastMove.to[0] === 3 && 
          lastMove.to[1] === toCol && fromRow === 3) {
        return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
      }
    }
    return false;
  }

  if (piece === '♟') {
    if (fromRow === 1) {
      if (toCol === fromCol && toRow === fromRow + 1 && !targetPiece || 
          toCol === fromCol && toRow === fromRow + 2 && !targetPiece && !currentBoard[fromRow + 1][fromCol]) {
        return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
      }
    }
    if (toCol === fromCol && toRow === fromRow + 1 && !targetPiece) {
      return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
    }
    if (Math.abs(toCol - fromCol) === 1 && toRow === fromRow + 1) {
      if (targetPiece && isOpposingTeamPiece(targetPiece)) {
        return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
      }
      if (!targetPiece && lastMove && lastMove.piece === '♙' && 
          lastMove.from[0] === 6 && lastMove.to[0] === 4 && 
          lastMove.to[1] === toCol && fromRow === 4) {
        return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
      }
    }
    return false;
  }

  if (piece === '♖' || piece === '♜') {
    if (fromRow !== toRow && fromCol !== toCol) return false;
    if (fromRow === toRow) {
      const step = Math.sign(toCol - fromCol);
      for (let col = fromCol + step; col !== toCol; col += step) {
        if (currentBoard[fromRow][col] !== '') return false;
      }
    } else {
      const step = Math.sign(toRow - fromRow);
      for (let row = fromRow + step; row !== toRow; row += step) {
        if (currentBoard[row][fromCol] !== '') return false;
      }
    }
    if (targetPiece && isCurrentTeamPiece(targetPiece)) {
      return false;
    }
    return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
  }

  if (piece === '♔' || piece === '♚') {
    if (Math.abs(toRow - fromRow) <= 1 && Math.abs(toCol - fromCol) <= 1) {
      if (targetPiece && isCurrentTeamPiece(targetPiece)) {
        return false;
      }
      return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
    }
    if (!kingMoved[isTopTeamPiece(piece) ? 'black' : 'white'] && 
        fromRow === toRow && Math.abs(toCol - fromCol) === 2) {
      if (toCol - fromCol === 2) {
        if (!rookMoved[isTopTeamPiece(piece) ? 'blackKing' : 'whiteKing'] && 
            !currentBoard[fromRow][fromCol + 1] && !currentBoard[fromRow][fromCol + 2] && 
            currentBoard[fromRow][7] === (isTopTeamPiece(piece) ? '♜' : '♖')) {
          return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
        }
      }
      if (toCol - fromCol === -2) {
        if (!rookMoved[isTopTeamPiece(piece) ? 'blackQueen' : 'whiteQueen'] && 
            !currentBoard[fromRow][fromCol - 1] && !currentBoard[fromRow][fromCol - 2] && 
            !currentBoard[fromRow][fromCol - 3] && 
            currentBoard[fromRow][0] === (isTopTeamPiece(piece) ? '♜' : '♖')) {
          return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
        }
      }
    }
    return false;
  }

  if (piece === '♗' || piece === '♝') {
    if (Math.abs(toRow - fromRow) !== Math.abs(toCol - fromCol)) {
      return false;
    }
    const rowStep = Math.sign(toRow - fromRow);
    const colStep = Math.sign(toCol - fromCol);
    for (let i = 1; i < Math.abs(toRow - fromRow); i++) {
      if (currentBoard[fromRow + i * rowStep][fromCol + i * colStep] !== '') {
        return false;
      }
    }
    if (targetPiece && isCurrentTeamPiece(targetPiece)) {
      return false;
    }
    return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
  }

  if (piece === '♕' || piece === '♛') {
    const isDiagonal = Math.abs(toRow - fromRow) === Math.abs(toCol - fromCol);
    const isStraight = fromRow === toRow || fromCol === toCol;
    if (!isDiagonal && !isStraight) {
      return false;
    }
    if (isStraight) {
      if (fromRow === toRow) {
        const step = Math.sign(toCol - fromCol);
        for (let col = fromCol + step; col !== toCol; col += step) {
          if (currentBoard[fromRow][col] !== '') return false;
        }
      } else {
        const step = Math.sign(toRow - fromRow);
        for (let row = fromRow + step; row !== toRow; row += step) {
          if (currentBoard[row][fromCol] !== '') return false;
        }
      }
    } else {
      const rowStep = Math.sign(toRow - fromRow);
      const colStep = Math.sign(toCol - fromCol);
      for (let i = 1; i < Math.abs(toRow - fromRow); i++) {
        if (currentBoard[fromRow + i * rowStep][fromCol + i * colStep] !== '') {
          return false;
        }
      }
    }
    if (targetPiece && isCurrentTeamPiece(targetPiece)) {
      return false;
    }
    return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
  }

  if (piece === '♘' || piece === '♞') {
    const rowDiff = Math.abs(toRow - fromRow);
    const colDiff = Math.abs(toCol - fromCol);
    if (!(rowDiff === 2 && colDiff === 1 || rowDiff === 1 && colDiff === 2)) {
      return false;
    }
    if (targetPiece && isCurrentTeamPiece(targetPiece)) {
      return false;
    }
    return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
  }

  return !wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece);
}

function isKingInCheck(isTopTeamKing, skipRecursion = false) {
  let kingRow = -1;
  let kingCol = -1;
  const kingPiece = isTopTeamKing ? '♚' : '♔';
  
  // Find king
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      if (currentBoard[row][col] === kingPiece) {
        kingRow = row;
        kingCol = col;
        break;
      }
    }
    if (kingRow !== -1) break;
  }
  const kingIndex = kingRow * 8 + kingCol;
  const moveTable = isTopTeamKing ? BOTTOM_MOVES : TOP_MOVES;
  
  // Check each square for potential threats
  for (let fromRow = 0; fromRow < 8; fromRow++) {
    for (let fromCol = 0; fromCol < 8; fromCol++) {
      const piece = currentBoard[fromRow][fromCol];
      if (!piece || isTopTeamPiece(piece) === isTopTeamKing) continue;
      
      const index = (fromRow * 8 + fromCol) * 64 + kingIndex;
      const possibleMoves = moveTable[index];
      
      // Quick checks for pieces that don't need path validation
      if ((piece === '♙' || piece === '♟') && possibleMoves & MOVES.PAWN_CAPTURE) {
        return true;
      }
      if ((piece === '♘' || piece === '♞') && possibleMoves & MOVES.KNIGHT_CAPTURE) {
        return true;
      }
      if ((piece === '♔' || piece === '♚') && possibleMoves & MOVES.KING_CAPTURE) {
        return true;
      }
      
      // For other pieces, validate path is clear
      if (possibleMoves) {
        if (isValidMove(fromRow, fromCol, kingRow, kingCol)) {
          return true;
        }
      }
    }
  }
  return false;
}

function wouldLeaveKingInCheck(fromRow, fromCol, toRow, toCol, piece) {
  console.log('\nChecking move from', fromRow, fromCol, 'to', toRow, toCol);
  console.log('Moving piece:', piece);
  
  // First check which king we should be protecting
  const isOurPieceTop = isTopTeamPiece(piece);
  console.log('This is a', isOurPieceTop ? 'top' : 'bottom', 'team piece');
  
  // Make temporary move
  const tempBoard = currentBoard.map(row => [...row]);
  tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];
  tempBoard[fromRow][fromCol] = '';

  // Check if our own king would be in check after this move
  const inCheck = checkKingInDanger(isOurPieceTop, tempBoard);
  
  console.log('Our king would be in check after this move?', inCheck);
  
  // If it was already in check before the move, show that too
  const wasInCheck = checkKingInDanger(isOurPieceTop, currentBoard);
  console.log('Our king was in check before the move?', wasInCheck);
  
  return inCheck;
}

function showValidMoves(row, col) {
  const piece = currentBoard[row][col];
  console.log('Showing moves for piece:', piece);
  console.log('Current king in check?', isCurrentKingInCheck());
  if (piece === '♠' || piece === '♤') {
    for (let toRow = 0; toRow < 8; toRow++) {
      for (let toCol = 0; toCol < 8; toCol++) {
        if (isValidDeighMove(row, col, toRow, toCol)) {
          if (!wouldLeaveKingInCheck(row, col, toRow, toCol, piece)) {
            const square = document.querySelectorAll('.square')[toRow * 8 + toCol];
            if (currentBoard[toRow][toCol]) {
              square.classList.add('valid-capture');
            } else {
              square.classList.add('valid-move');
            }
          }
        }
      }
    }
  } else if (piece === '♙' || piece === '♟') {
    for (let toRow = 0; toRow < 8; toRow++) {
      for (let toCol = 0; toCol < 8; toCol++) {
        if (isValidMove(row, col, toRow, toCol)) {
          if (!wouldLeaveKingInCheck(row, col, toRow, toCol, piece)) {
            const square = document.querySelectorAll('.square')[toRow * 8 + toCol];
            if (Math.abs(toCol - col) === 1 && !currentBoard[toRow][toCol]) {
              square.classList.add('valid-enpassant');
            } else if (currentBoard[toRow][toCol]) {
              square.classList.add('valid-capture');
            } else {
              square.classList.add('valid-move');
            }
          }
        }
      }
    }
  } else if (piece === '♔' || piece === '♚') {
    for (let toRow = 0; toRow < 8; toRow++) {
      for (let toCol = 0; toCol < 8; toCol++) {
        if (isValidMove(row, col, toRow, toCol)) {
          if (!wouldLeaveKingInCheck(row, col, toRow, toCol, piece)) {
            const square = document.querySelectorAll('.square')[toRow * 8 + toCol];
            if (Math.abs(toCol - col) === 2) {
              square.classList.add('valid-castle');
            } else if (currentBoard[toRow][toCol]) {
              square.classList.add('valid-capture');
            } else {
              square.classList.add('valid-move');
            }
          }
        }
      }
    }
  } else if (piece === '♖' || piece === '♜') {
    for (let toRow = 0; toRow < 8; toRow++) {
      for (let toCol = 0; toCol < 8; toCol++) {
        if (isValidMove(row, col, toRow, toCol)) {
          if (!wouldLeaveKingInCheck(row, col, toRow, toCol, piece)) {
            const square = document.querySelectorAll('.square')[toRow * 8 + toCol];
            if (currentBoard[toRow][toCol]) {
              square.classList.add('valid-capture');
            } else {
              square.classList.add('valid-move');
            }
          }
        }
      }
    }
  } else {
    for (let toRow = 0; toRow < 8; toRow++) {
      for (let toCol = 0; toCol < 8; toCol++) {
        if (isValidMove(row, col, toRow, toCol)) {
          if (!wouldLeaveKingInCheck(row, col, toRow, toCol, piece)) {
            const square = document.querySelectorAll('.square')[toRow * 8 + toCol];
            if (currentBoard[toRow][toCol]) {
              square.classList.add('valid-capture');
            } else {
              square.classList.add('valid-move');
            }
          }
        }
      }
    }
  }
}
function clearHighlights() {
  document.querySelectorAll('.square').forEach(square => {
    square.classList.remove('selected', 'valid-move', 'valid-capture', 'valid-enpassant', 'valid-castle');
  });
}
function updateBoard() {
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const square = document.querySelectorAll('.square')[row * 8 + col];
      const piece = currentBoard[row][col];
      const existingIndicator = square.querySelector('.king-check-indicator');
      if (existingIndicator) {
        square.removeChild(existingIndicator);
      }
      if (piece) {
        let pieceHtml = `<span class="piece ${isTopTeamPiece(piece) ? 'top' : 'bottom'}">${piece}</span>`;
        square.innerHTML = pieceHtml;
      } else {
        square.innerHTML = '';
      }
    }
  }
  const topTeamChecked = isKingInCheck(true);
  const bottomTeamChecked = isKingInCheck(false);
  if (topTeamChecked || bottomTeamChecked) {
    debug.textContent = "Warning: " + (topTeamChecked ? "Top " : "") + (topTeamChecked && bottomTeamChecked ? "and " : "") + (bottomTeamChecked ? "Bottom " : "") + "king" + (topTeamChecked && bottomTeamChecked ? "s are" : " is") + " in check!";
  }
  updateMoveStatus();
}
document.getElementById('newGame').addEventListener('click', () => {
  sideChosen = false;
  topTeamMovedFirst = null;
  bottomTeamMovedFirst = null;
  isTopTeamsTurn = null;
  selectedSquare = null;
  moveHistory = [];
  animationFrame = 0;
  chosenColor = null;
  board.classList.add('cycling');
  initializeBoard();
  status.textContent = "Either side to move";
});
document.getElementById('undoMove').addEventListener('click', () => {
  if (moveHistory.length > 0) {
    const moveToUndo = moveHistory.pop();
    
    // For en passant, restore the captured pawn to its original square
    const wasEnPassant = (moveToUndo.piece === '♙' || moveToUndo.piece === '♟') && 
                        Math.abs(moveToUndo.to[1] - moveToUndo.from[1]) === 1 && 
                        !moveToUndo.capturedPiece;
    if (wasEnPassant) {
      currentBoard[moveToUndo.from[0]][moveToUndo.to[1]] = currentBoard[moveToUndo.to[0]][moveToUndo.to[1]] === '♙' ? '♟' : '♙';
    }
    
    // Regular move undo
    currentBoard[moveToUndo.from[0]][moveToUndo.from[1]] = moveToUndo.piece;
    currentBoard[moveToUndo.to[0]][moveToUndo.to[1]] = moveToUndo.capturedPiece || '';
    kingMoved = JSON.parse(JSON.stringify(moveToUndo.kingMoved));
    rookMoved = JSON.parse(JSON.stringify(moveToUndo.rookMoved));
    if ((moveToUndo.piece === '♔' || moveToUndo.piece === '♚') && Math.abs(moveToUndo.to[1] - moveToUndo.from[1]) === 2) {
      if (moveToUndo.to[1] > moveToUndo.from[1]) {
        currentBoard[moveToUndo.from[0]][7] = currentBoard[moveToUndo.from[0]][moveToUndo.to[1] - 1];
        currentBoard[moveToUndo.from[0]][moveToUndo.to[1] - 1] = '';
      } else {
        currentBoard[moveToUndo.from[0]][0] = currentBoard[moveToUndo.from[0]][moveToUndo.to[1] + 1];
        currentBoard[moveToUndo.from[0]][moveToUndo.to[1] + 1] = '';
      }
    }
    isTopTeamsTurn = !isTopTeamsTurn;

    // Update lastMove to previous move
    lastMove = moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;

    // Show the previous move in debug if there is one
    if (moveHistory.length > 0) {
      const previousMove = moveHistory[moveHistory.length - 1];
      const pieceName = previousMove.piece === '♙' || previousMove.piece === '♟' ? 'pawn' :
                       previousMove.piece === '♖' || previousMove.piece === '♜' ? 'rook' :
                       previousMove.piece === '♘' || previousMove.piece === '♞' ? 'knight' :
                       previousMove.piece === '♗' || previousMove.piece === '♝' ? 'bishop' :
                       previousMove.piece === '♕' || previousMove.piece === '♛' ? 'queen' :
                       previousMove.piece === '♔' || previousMove.piece === '♚' ? 'king' :
                       previousMove.piece === '♤' || previousMove.piece === '♠' ? 'deigh' : '';
      
      let moveType = '';
      // Detect en passant from move data
      const wasEnPassant = (previousMove.piece === '♙' || previousMove.piece === '♟') && 
                          Math.abs(previousMove.to[1] - previousMove.from[1]) === 1 && 
                          !previousMove.capturedPiece;
                          
      if (wasEnPassant) {
        moveType = ' capturing en passant';
      } else if (previousMove.capturedPiece) {
        moveType = ` capturing ${previousMove.capturedPiece}`;
      } else if ((previousMove.piece === '♔' || previousMove.piece === '♚') && 
                 Math.abs(previousMove.to[1] - previousMove.from[1]) === 2) {
        moveType = previousMove.to[1] > previousMove.from[1] ? ' (kingside castle)' : ' (queenside castle)';
      }

      debug.textContent = `${pieceName} (${previousMove.piece}) moved from ${String.fromCharCode(97 + previousMove.from[1])}${8 - previousMove.from[0]} to ${String.fromCharCode(97 + previousMove.to[1])}${8 - previousMove.to[0]}${moveType}`;
    } else {
      debug.textContent = "chess with deigh support";
    }
    
    updateBoard();
    updateMoveStatus();
  }
});

let cyclingEnabled = false;
setTimeout(() => {
  if (!sideChosen) {
    cyclingEnabled = true;
    board.classList.add('cycling');
  }
}, 5000);  // 5 second delay

let secondaryCounter = -4;
let tertiaryCounter = 2;
let currentDisplayedBottomColor = '#bbb';
let currentDisplayedTopColor = '#444';
let boardColorCounter = 0;

setInterval(() => {
  if (!sideChosen) {
    animationFrame = (animationFrame + 1) % (numColors * 2);
    const displayIndex = Math.floor(animationFrame / 2) % numColors;
    boardColorCounter++;  // Just keep counting up
    
    if (animationFrame % 2 === 0) {
      secondaryCounter++;
      if (secondaryCounter === tertiaryCounter) {
        secondaryCounter = 0;
        tertiaryCounter++;
      }
    }
    
    let bottomColor, topColor, lightSquareColor, darkSquareColor;
    lightSquareColor = lightSquareColors[boardColorCounter % numLightSquareColors];
    darkSquareColor = darkSquareColors[boardColorCounter % numDarkSquareColors];
    if (secondaryCounter < 2) {
      if (tertiaryCounter % 2 === 0) {
        bottomColor = '#fffff6';
        topColor = '#0a0800';
      } else {
        bottomColor = '#0a0800';
        topColor = '#fffff6';
      }
    } else {
      const displayIndex = Math.floor(animationFrame / 2) % numColors;
      bottomColor = bottomPlayerColors[displayIndex];
      topColor = topPlayerColors[displayIndex];
      console.log('Cycling colors:', {bottomColor, topColor, lightSquareColor, darkSquareColor});  // Debug
    }
    
    if (Math.random() < 0.5) {
      document.documentElement.style.setProperty('--bottom-color', bottomPlayerColors[displayIndex]);
    } else {
      document.documentElement.style.setProperty('--bottom-color', bottomColor);
    }

    if (Math.random() < 0.5) {
      document.documentElement.style.setProperty('--top-color', topColor);
    } else {
      document.documentElement.style.setProperty('--top-color', topPlayerColors[displayIndex]);
    }
    document.documentElement.style.setProperty('--board-color-light', lightSquareColor);
    document.documentElement.style.setProperty('--board-color-dark', darkSquareColor);
  }
}, 3000);

function updateMoveStatus() {
    if (!sideChosen) {
        status.textContent = "Either side to move";
        return;
    }
    
    // If a piece is selected, show which piece
    if (selectedSquare) {
        const [row, col] = selectedSquare;
        const piece = currentBoard[row][col];
        const pieceName = piece === '♙' || piece === '♟' ? 'pawn' :
                         piece === '♖' || piece === '♜' ? 'rook' :
                         piece === '♘' || piece === '♞' ? 'knight' :
                         piece === '♗' || piece === '♝' ? 'bishop' :
                         piece === '♕' || piece === '♛' ? 'queen' :
                         piece === '♔' || piece === '♚' ? 'king' :
                         piece === '♤' || piece === '♠' ? 'deigh' : '';
        status.textContent = `Selected ${pieceName} (${piece}) at ${String.fromCharCode(97 + col)}${8 - row}`;
        return;
    }
    
    // Otherwise show whose turn it is
    const isTopTurn = moveHistory.length % 2 === 0 === topTeamMovedFirst;
    const inCheck = checkKingInDanger(isTopTurn, currentBoard);
    status.textContent = (isTopTurn ? "Top" : "Bottom") + " player to move" + (inCheck ? " - King is in check!" : "");
}

function getBoardAsText() {
  let result = '';
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      result += currentBoard[row][col] || ' ';
    }
    result += '\n';
  }
  return result;
}
document.getElementById('copyBoard').addEventListener('click', async () => {
  try {
    const text = getBoardAsText();
    await navigator.clipboard.writeText(text);
    debug.textContent = "Board copied to clipboard!";
  } catch (err) {
    debug.textContent = "Failed to copy board: " + err;
  }
});
initializeMoveTables();
initializeBoard();</script>
</body></html>

